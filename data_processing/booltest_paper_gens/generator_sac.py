#!/usr/bin/python3

import argparse
import json
import os
import subprocess
import sys
from copy import deepcopy

from joblib import Parallel, delayed

rtt_prefix = 'sac_seed_1fe40505e131963c_8gb_'
# def confs
config_base = {
    'notes': 'generated by generator.py',
    'seed': '1fe40505e131963c',
    'tv-size': None,
    'tv-count': None
}
counter_stream = {
    'type': 'counter'
}
hw_stream = {
    'type': 'hw-counter',
    'hw': 4
}
random_stream = {
    'type': 'pcg32-stream'
}
false_stream = {
    'type': 'false-stream'
}
rnd_plt_ctx_stream = {
    'type': 'rnd-plt-ctx-stream',
    'source': None
}
sac_stream = {
    'type': 'sac'
}
plaintext_target_stream = sac_stream


class FunArgs:
    def __init__(self, block_size, key_size, rounds=()):
        self.block_size = block_size
        self.key_size = key_size
        self.rounds = rounds

# used funs in batch
estream_funs = {
    # 'Grain': (0, 1, 2, 3),
    # 'HC-128': (1,),
    # 'MICKEY': (),
    # 'Rabbit': (0, 4),
    # 'Salsa20': (2, 4, 6),
    # 'SOSEMANUK': (3, 4, 5, 6),
    # 'Trivium': (),
    # 'F-FCSR': ()
}
estream_default = {
    'type': 'estream',
    'generator': 'pcg32',
    'init-frequency': 'only-once',
    'algorithm': None,
    'round': None,
    'block-size': 16,
    'plaintext-type': plaintext_target_stream,
    'key-size': 16,
    'key-type': random_stream,
    'iv-size': 16,
    'iv-type': false_stream
}

hash_funs = {
    'BLAKE': (0, 1, 2, 3),
    'Grostl': (1, 2),
    'JH': (5, 6, 7, 8),
    'Keccak': (1, 2, 3),
    'MD6': (5, 6, 7, 8, 9),
    'Skein': (2, 3, 4)
}
hash_default = {
    'type': 'sha3',
    'generator': 'pcg32',
    'init-frequency': 'only-once',
    'algorithm': None,
    'round': None,
    'block-size': 32,  # bug
    'hash-size': 32,
    'input-size': 32,
    'source': plaintext_target_stream
}

# ph4 hotfix
hash2_funs = {
    'Gost': FunArgs(32, None, (1, 2, 3)),
    'MD5': FunArgs(16, None, (9, 10, 11, 12, 13, 14, 15)),
    'RIPEMD160': FunArgs(20, None, (8, 9, 10, 11, 12, 13, 14, 15)),
    'SHA1': FunArgs(20, None, (11, 12, 13, 14, 15, 16, 17, 18)),
    'SHA256': FunArgs(32, None, (10, 11, 12, 13)),
    'Tiger': FunArgs(24, None, (1, 2)),
    'Whirlpool': FunArgs(64, None, (2, 4)),
}
hash2_default = {
    'type': 'hash',
    'generator': 'pcg32',
    'init-frequency': 'only-once',
    'algorithm': None,
    'round': None,
    'block-size': None,  # bug
    'hash-size': None,
    'input-size': None,
    'source': plaintext_target_stream
}


block_funs = {
    'AES': FunArgs(16, 16, (1, 2, 3, 4)),
    'BLOWFISH': FunArgs(8, 32, (1, 2, 3)),
    'MARS': FunArgs(16, 16, (0, 1)),
    'TWOFISH': FunArgs(16, 16, (1, 2, 3, 4)),
    'SERPENT': FunArgs(16, 16, (1, 2, 3, 4)),
    'RC6': FunArgs(16, 16, (1, 2, 3, 4)),
    #'RC4': FunArgs(16, 16, (1,)),
    'SIMON': FunArgs(16, 16, (12, 13, 14, 15, 16, 17, 18, 19)),
    'SPECK': FunArgs(16, 16, (5, 6, 7, 8)),
    'SINGLE-DES': FunArgs(8, 8, (3, 4, 5, 6)),
    'TRIPLE-DES': FunArgs(8, 24, (1, 2, 3)),
    'TEA': FunArgs(8, 16, (2, 3, 4, 5)),
    'GOST': FunArgs(8, 32, (5, 6, 7, 8, 9)),
    
    'ARIA': FunArgs(16, 16, (1, 2, 3)),
    'CAMELLIA': FunArgs(16, 16, (2, 3, 4, 5)),
    'CAST': FunArgs(8, 16, (2, 3, 4, 5)),
    'IDEA': FunArgs(8, 16, (1, 2, 3)),
    'SEED': FunArgs(16, 16, (1, 2, 3, 4)),
}
block_default = {
    'type': 'block',
    'init-frequency': 'only-once',
    'algorithm': None,
    'round': None,
    'block-size': 16,
    'plaintext': plaintext_target_stream,
    'key-size': 16,
    'key': random_stream,
    'iv-size': 16,
    'iv': false_stream
}


def get_tv_size(main_args):
    if main_args.stream_type == "estream":
        return 16
    if main_args.stream_type == "sha3":
        return 32
    if main_args.stream_type == "block":
        return block[main_args.fun].block_size
    return 16


def prepare_cfg(project, fun, rounds, tv_size, tv_num):
    cfg_name = '{}_r{:02d}_b{}.json'.format(fun, rounds, tv_size)

    with open(cfg_name, 'w') as f:

        current_cfg = deepcopy(config_base)
        current_cfg['tv-size'] = tv_size
        current_cfg['tv-count'] = tv_num

        if project == "estream":
            stream = deepcopy(estream_default)
            stream['algorithm'] = fun
            stream['round'] = rounds
            current_cfg['stream'] = stream

        elif project == "sha3":
            stream = deepcopy(hash_default)
            stream['algorithm'] = fun
            stream['round'] = rounds
            current_cfg['stream'] = stream

        elif project == "hash":
            stream = deepcopy(hash2_default)
            stream['algorithm'] = fun
            stream['round'] = rounds
            stream['block-size'] = hash2_funs[fun].block_size
            stream['hash-size'] = hash2_funs[fun].block_size
            stream['input-size'] = hash2_funs[fun].block_size
            current_cfg['stream'] = stream

        elif project == "block":
            stream = deepcopy(block_default)
            stream['algorithm'] = fun
            stream['round'] = rounds
            stream['block-size'] = block_funs[fun].block_size
            stream['key-size'] = block_funs[fun].key_size
            current_cfg['stream'] = stream

        else:  # rnd
            stream = deepcopy(random_stream)
            stream['algorithm'] = fun
            stream['round'] = 0
            stream['block-size'] = 16
            current_cfg['stream'] = stream

        f.write(json.dumps(current_cfg))
        f.close()

    return cfg_name


def run_single(args):
    project, fun, rounds, tv_size, data, num_tv, generator_binary = args
    cfg_name = prepare_cfg(project, fun, rounds, tv_size, num_tv)
    cmd = '{} -c={}'.format(generator_binary, cfg_name)
    print("Executing: " + cmd)
    process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
    process.wait()
    binfile_name = cfg_name.split('.')[0] + '.bin'

    cfg_size = ['1MB.json', '10MB.json', '100MB.json', 'default-8GB.json']
    if 1000000 <= data < 10000000:
        cfg = cfg_size[0]
    elif 10000000 <= data < 100000000:
        cfg = cfg_size[1]
    elif 100000000 <= data < 8000000000:
        cfg = cfg_size[2]
    elif 8000000000 <= data:
        cfg = cfg_size[3]
    else:
        exit("Too small data for testing.")
        return None
    cmd = 'submit_experiment --all_batteries -c {0} -f {1} -n {2}{1}'.format(cfg, binfile_name, rtt_prefix)
    print("Executing: " + cmd)
    process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
    process.wait()
    cmd = 'rm {0}'.format(binfile_name)
    print("Executing: " + cmd)
    process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
    process.wait()


def single_setup_generator(generator_binary, data=None, num_tv=None):
    for estream_fun in estream_funs:
        for rounds in estream_funs[estream_fun]:
            if data:
                num_tv = data // 16
            else:
                data = num_tv * 16
            yield ['estream', estream_fun, rounds, 16, data, num_tv, generator_binary]
    for hash_fun in hash_funs:
        for rounds in hash_funs[hash_fun]:
            if data:
                num_tv = data // 32
            else:
                data = num_tv * 32
            yield ['sha3', hash_fun, rounds, 32, data, num_tv, generator_binary]
    for hash2_fun in hash2_funs:
        args = hash2_funs[hash2_fun]
        for rounds in args.rounds:
            if data:
                num_tv = data // args.block_size
            else:
                data = num_tv * args.block_size
            yield ['hash', hash2_fun, rounds, args.block_size, data, num_tv, generator_binary]
    for block_fun in block_funs:
        args = block_funs[block_fun]
        for rounds in args.rounds:
            if data:
                num_tv = data // args.block_size
            else:
                data = num_tv * args.block_size
            yield ['block', block_fun, rounds, args.block_size, data, num_tv, generator_binary]


def run_all(binary, data=None, num_tv=None):
    Parallel(n_jobs=-1)(delayed(run_single)(single_setup)
                        for single_setup in single_setup_generator(binary, data, num_tv))


def main_args_to_fnc(main_args):
    project = main_args.stream_type
    fun = main_args.fun
    rounds = main_args.rounds

    tv_size = get_tv_size(main_args)
    tv_num = (main_args.num // tv_size) if main_args.data else main_args.num

    prepare_cfg(project, fun, rounds, tv_size, tv_num)


def main():
    parser = argparse.ArgumentParser()
    single_execution_args(parser)
    parser.add_argument(
        '-a',
        '--all',
        action='store_true',
        default=False,
        help='Whether we should execute all experiments, or just single one'
    )
    parser.add_argument(
        '-p',
        '--path_to_generator_binary',
        type=str,
        default='./generator',
        help='Path to the binary of generator (or newly called eacirc_streams binary)'
    )
    group = parser.add_mutually_exclusive_group()
    group.add_argument(
        '-n',
        '--num_tv',
        action='store_true',
        default=False,
        help='Number of test vectors generated'
    )
    group.add_argument(
        '-d',
        '--data',
        action='store_true',
        default=False,
        help='Number of generated bytes'
    )
    parser.add_argument(
        'num',
        metavar='N',
        type=int,
        default=1000000,
        help='the number of TV or data')
    main_args, _ = parser.parse_known_args()

    if main_args.num_tv == main_args.data:
        sys.exit('Choose EITHER --num_tv or --data')

    if main_args.all:
        print('Running all experiments')
        data = main_args.num if main_args.data else None
        num_tv = main_args.num if main_args.num_tv else None
        run_all(main_args.path_to_generator_binary, data=data, num_tv=num_tv)
    else:
        single_execution_parse(main_args)
        main_args_to_fnc(main_args)
        os.system(main_args.path_to_generator_binary)


def single_execution_parse(main_args):
    if main_args.stream_type == '':
        if main_args.fun in estream:
            main_args.stream_type = 'estream'
        elif main_args.fun in sha:
            main_args.stream_type = 'sha3'
        elif main_args.fun in block:
            main_args.stream_type = 'block'
        else:
            sys.exit('Unknown function and unspecified stream. Set -s! Function was: ' + main_args.fun)
    else:
        if main_args.fun in estream and main_args.stream_type != 'estream':
            sys.exit('Mismatch arguments: function '
                     + main_args.fun
                     + ' is from estream, your stream_type is '
                     + main_args.stream_type)
        elif main_args.fun in sha and main_args.stream_type != 'sha3':
            sys.exit('Mismatch arguments: function '
                     + main_args.fun
                     + ' is from sha3, your stream_type is '
                     + main_args.stream_type)
        elif main_args.fun in block and main_args.stream_type != 'block':
            sys.exit('Mismatch arguments: function '
                     + main_args.fun
                     + ' is from block, your stream_type is '
                     + main_args.stream_type)
    if main_args.stream_type == 'block' and main_args.fun not in block:
        sys.exit('Unknown block function ' + main_args.fun)
    print('generator.py: preparing config for function '
          + main_args.fun
          + ' from '
          + main_args.stream_type
          + ' reduced to '
          + str(main_args.rounds)
          + ' rounds.')


def single_execution_args(parser):
    parser.add_argument(
        '-s',
        '--stream_type',
        type=str,
        default='',
        help='Stream: for AES, DES... = block, Salsa... = estream, Keccak... = sha3'
    )
    parser.add_argument(
        '-f',
        '--fun',
        type=str,
        default='PRNG',
        help='Function used for data generation'
    )
    parser.add_argument(
        '-r',
        '--rounds',
        type=int,
        default=1,
        help='Function is reduced to --rounds'
    )


if __name__ == '__main__':
    main()
